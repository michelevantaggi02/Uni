Per descrivere qualsiasi cosa usiamo delle parole. Un linguaggio Ã¨ un insieme di parole che possono essere elencate se si tratta di un insieme finito.

``````ad-question
title: Come possiamo descrivere un insieme infinito?

```ad-important
title: Teorema di Cantor

Non esiste una funzione iniettiva che descriva un linguaggio infinito, quindi non Ã¨ possibile associare a ciascun linguaggio una parola che lo caratterizzi univocamente

```


``````


```ad-info
title: Chiusura di Kleene

La chiusura di Kleene di un linguaggio $L$ Ã¨ il linguaggio $L*$ costituito dalla parola vuota, dalle parole di $L$ e da tutte quelle che si ottengono concatenando due o piÃ¹ parole di $L$. Se $L$ Ã¨ un linguaggio finito, il linguaggio $L*$ Ã¨ ben definito e, in generale, infinito.

```

```ad-example

Prendo 3 nomi: "Aldo, Bianca e Carlo":
- I nomi sono separati da virgola, tranne gli ultimi due che sono separati da "e"
- Sono ammesse ripetizioni
- Nessun limite di lunghezza

Le __frasi__ sono definite dalle seguenti regole:
- Aldo, Bianca e Carlo sono __nomi__
- un __nome__ singolo Ã¨ una __frase__
- un __nome__ seguito da una __virgola__ e una __frase__ Ã¨ anch'esso una __frase__
- Se sono presenti virgole, l'ultima deve essere sostituita con __e__

```

# Parole

Un __alfabeto__ Ã¨ un insieme finito non vuoto $\sum$ di simboli chiamati __lettere__

```ad-important
title: Parole

Ogni sequenza finita di lettere di $\sum$ si dice __parola__ sull'alfabeto $\sum$. L'insieme delle parole si indica con $\sum *$ 

```

## Lunghezza

Una parola $u$ Ã¨ una sequenza

$$u=a_1a_2...a_k,\quad k \geq 0, a_1,...,a_k \in \sum$$

$k$ si chiama __lunghezza__ della parola $u$ e si denota con $|u|$

```ad-important
title: Importante

Esiste una parola di lunghezza 0 chiamata __parola vuota__ che si denota con $\varepsilon$ 

```

## Concatenazione

$$u=a_1a_2...a_k$$

$$v=b_1b_2...b_h$$

Date due parole $u$ e $v$, la loro __concatenazione__ Ã¨ la parola:

$$uv=a_1a_2...a_kb_1...b_h$$

### ProprietÃ 

La concatenazione Ã¨ un'operazione binaria su $\sum*$ e verifica le seguenti proprietÃ :

- __associativa__: $\forall u,v,w \in \sum*, \quad (uv)w = u(vw)$
- __elemento neutro__:$\forall u \in \sum* \quad u\varepsilon=\varepsilon u = u$
- __cancellativitÃ __: se si ha $uw=vw$ o $wu=wv$ con $u,v,w \in \sum*$ allora $u=v$

### Potenza

Sia $n \geq 0$ la __potenza n-esima__ si ottiene concatenando $n$ volte la parola $w$

$$w^n=ww...w$$

$$w^0=\varepsilon,\quad w^1=w$$

### Fattore

Una parola $v \neq w$ Ã¨ un __fattore__ se $w = xvy$ per opportune parole $x,y$.

Nel caso in cui $x=\varepsilon$ (oppure $y=\varepsilon$) il fattore $v$ si dice __prefisso__ (oppure __suffisso__).

# Linguaggi Formali

Ogni __sottoinsieme__ di $\sum*$ Ã¨ un __linguaggio formale__ sull'alfabeto $\sum$

```ad-example

Dato l'alfabeto $\sum = \{a,b\}$ sono linguaggi formali:
$$L_0=\{a,b\}$$
$$L_1=\{a,ab,abb\}$$
$$L_2=\{ab^na | n \geq 0\}$$


```

# Grammatica

Una __grammatica a struttura di frase__ Ã¨ una quadrupla

$$G = âŸ¨V , Î£, P, SâŸ©,$$

- $V$ alfabeto finito
- $Î£ âŠ† V$ Ã¨ l'alfabeto dei __simboli terminali__
- P Ã¨ un insieme finito di espressioni $$\alpha \to \beta$$ con $ð›¼ âˆˆ V * âˆ– Î£ * e ð›½ âˆˆ V *$ detto __insieme delle produzioni__
- $S âˆˆ N = V âˆ– Î£$ Ã¨ il __simbolo iniziale__ o __assioma__
Le lettere di $N = V âˆ– Î£$ si dicono __variabili__

## Linguaggio Generato

Dati $ð›¼, ð›½ âˆˆ V *$ :

- $\beta$ Ã¨ una __conseguenza diretta__ di $\alpha$ ($\alpha \implies \beta$) se esistono parole $ð›¾1, ð›¾2 âˆˆ V *$ e una produzione $ð›¾ â†’ ð›¾ â€²$ in P tali che $$ð›¼ = ð›¾1ð›¾ð›¾2,\quad ð›½ = ð›¾1ð›¾ â€² ð›¾2$$
- $\beta$ si __deriva__ (Ã¨ una _conseguenza_ ) di $ð›¼$ in G ($ð›¼ â‡’* ð›½$) se esistono $n > 0, ð›¼_0, ð›¼_1, . . . , ð›¼_n âˆˆ V *$ tali che $$ð›¼ = ð›¼_0 â‡’ ð›¼_1 â‡’ Â· Â· Â· â‡’ ð›¼_n = ð›½ $$
- Le conseguenze del simbolo iniziale $S$ si dicono __forme sentenziali__
- il __linguaggio generato__ da G Ã¨ l'insieme delle forme sentenziali prive di variabili

```ad-example

Variabili: $âŸ¨fraseâŸ©, âŸ¨listaNomiâŸ©, âŸ¨fineListaâŸ©, âŸ¨nomeâŸ©$

I terminali sono le lettere delle parole Aldo, Bianca, Carlo, e, virgola, spazio

Le produzioni sono:
$$\begin{matrix}
âŸ¨nomeâŸ© â†’ Aldo &âŸ¨fraseâŸ© â†’ âŸ¨listaNomiâŸ©âŸ¨fineListaâŸ© \\âŸ¨nomeâŸ© â†’ Bianca &âŸ¨listaNomiâŸ© â†’ âŸ¨nomeâŸ© \\âŸ¨nomeâŸ© â†’ Carlo &âŸ¨listaNomiâŸ© â†’ âŸ¨nomeâŸ©, âŸ¨listaNomiâŸ© \\âŸ¨fraseâŸ© â†’ âŸ¨nomeâŸ©& ,âŸ¨nomeâŸ© âŸ¨fineListaâŸ© â†’ e \;âŸ¨nomeâŸ©
\end{matrix}$$

```

```ad-example

$$

```
```ad-example

$$G = âŸ¨V , Î£, P, SâŸ©, V = \{a, b, S\}, Î£ = \{a, b\}, N = \{S\},$$

$$P : S â†’ ab ,\quad S â†’ aSb $$

Le conseguenze (dirette e non) sono:
$$bSa â‡’ baba,\; aS â‡’ aaSb,\; aaSb â‡’ aaaSbb,\; aS *â‡’ aaaSbb$$

Il linguaggio generato Ã¨ quindi:
$$S â‡’ aSb â‡’ aaSbb â‡’ Â· Â· Â· â‡’ a ^{nâˆ’1}Sb^{nâˆ’1} â‡’ a^n b^n .$$

e quindi $$S(G) = \{a^n Sb^n | n > 0\} âˆª \{a ^n b ^n | n > 0\} $$$$ L(G) = \{a ^n b ^n | n > 0\} .$$


```

``````ad-example

A partire dal linguaggio costruire la grammatica:
$$L = {a ^n b ^n c ^n | n > 0} .$$

prendiamo $G = âŸ¨V , Î£, P, SâŸ©,\; Î£ = \{a, b, c\},\; N = \{S, B\}$ con le produzioni:$$S â†’ aSBc ,\; S â†’ abc ,\; cB â†’ Bc ,\; bB â†’ bb$$

L'idea Ã¨ quella di usare la variabile $B$ per scavalcare la $c$ e arrivare alla $b$ accumulandole e trasformando poi $bB\to bb$

```ad-check

Con $a^3b^3c^3$ $$S â‡’ aSBc â‡’ aaSBcBc â‡’ aaabcBcBc $$$$â‡’ aaabBccBc â‡’ aaabBcBcc â‡’ aaabBBccc â‡’ aaabbBccc â‡’ aaabbbccc$$

```
``````




```ad-important
title: Grammatiche equivalenti

Due grammatiche si dicono __equivalenti__ se generano lo stesso linguaggio

```

# Ricognizione E Parsing

## Problema di ricognizione

Se data unna grammatica e una parola si controlli se la parola appartiene al linguaggio di quella grammatica

## Problema di parsing

Data una grammatica e una parola si trovi una derivazione che partendo dal simbolo iniziale fino ad arrivare alla parola.

```ad-missing

Non esiste un algoriitmo che risolva questi problemi nel caso generale, bisogna quindi stringersi a casi specifici

```
