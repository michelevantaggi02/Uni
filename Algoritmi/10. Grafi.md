I grafi sono formati da due insiemi:

- Insieme dei vertici ($V$)
- Insieme degli archi ($E$)

$$G=(V,E)$$

# Insieme Dei Vertici

$$V=\{1,2,3,4\}$$

# Insieme Degli Archi

$$E=\{(1,2),(1,3),(2,3),(2,4),(3,4)\}$$

è formato da coppie di vertici, se le coppie sono __ordinate__ il grafo è __orientato__, se __non sono ordinate__ il grafo è __non orientato__.

# Grafo Bipartito

è un grafo che ha come vertici due insiemi separati, i cui archi collegano solo i vertici di un insieme ai vertici dell'altro, non ci sono collegamenti tra vertici dello stesso sottoinsieme.

![[Pasted image 20230301094454.png|center]]

```ad-example

$$R=\{1,2,3\}$$
$$L=\{4,5,6\}$$
$$V=\{L\cup R\}$$
$$E=\{(1,4), (4,3), (2,5)\}$$
```

## Mesh

I grafi a maglia possono essere impostati come dei grafi bipartiti

![[Pasted image 20230302164647.png|center]]

# Aisle Graph (Modello frutteto)

![[Pasted image 20230301094535.png|center]]

# Reti

![[Pasted image 20230301094712.png|center]]

# Dimensione Dei Grafi

$$|V|=n$$

$$|E|=m \begin{cases}
|E| \leq \frac {n(n-1)}2 & \text{grafo non orientato}\\
|E| \leq n(n-1) & \text{grafo orientato}
\end{cases}$$
Un grafo connesso (con tutti i vertici connessi tra loro) non orientato di dimensione $|V|=n$ ha un numero di archi $|E|=\frac {n(n-1)}2$ 

# Grafo Connesso

Un grafo non orientato si definisce connesso se:

$$\forall z,u \in V, z \neq u$$
$$\exists u \sim z$$
```ad-important
title: Path ($\sim$)

Sequenza di vertici tale che ogni coppia di vertici consecutivi è legato da un arco

```


### Alberi

Un grafo connesso che ha il minor numero di archi possibile ($|E|  = |V| - 1$) si chiama albero, se si rimuove un arco questo grafo non è più connesso.

![[Pasted image 20230301101608.png| center]]

Se G ha $n-1$ vertici, ma è disconnesso allora non è un grafo.

# Esplorare Un Grafo

Dato un grafo connesso, esplorare G vuol dire estrarre un albero che esplora tutti i vertici di G

## Visita in Profondità (DFS-visit)

Depth First Search visit.

La DFS-visit è preceduta dalla procedura di inizializzazione

	initialize(G=(V,E))
		for v in V:
			color(v) = white
			P(v) = nil

L'obiettivo è quello di estrarre un __albero di copertura__ radicato nel primo vertice passato alla procedura  dfs-visit.

un vertice è:
- white: non visitato
- gray: visitato
- black: visitati tutti gli archi

Ogni volta che tocco un vertice mai esplorato vado a esplorare tutti i vertici a esso connessi.

	dfs-visit(G=(V.E), u):
		color(u) = grey
		for v in Adj(u):
			if color(v) == white:
				(u,v) in T
				P(v) = u
				dfs-visit(G, v)
			else if v != P(u):
				(u,v) in B
			else
				(u, v) in T
		color(u) = black

```ad-info

- Un grafo connesso è un __albero__ se _non esistono_ archi in $B$.
- Un grafo connesso ha un __ciclo__ se _esistono_ archi in $B$


```

## Grafo Orientato

Esplorazione di $G,\; v \in V$, visibilità di $v$ in $G$

Immagine 13-03-2023

	dfs-visit(G, v, time):
		color(v) = gray
		time++;
		d(v) = time
		for u in adj(v):
			if color(u) == white:
				(v, u) in T
				P(u) = v
				dfs-visit(G, u, time)
			if color(u) == gray:
				(v, u) in Backward
			if color(u) == black and d(v) < d(u): 
				(v, u) in Forward
			else:
				(v, u) in Cross
		color(v) == black
		time++
		f(v) = time

Un grafo orientato aciclico ha almeno un __sink__, cioè un vertice senza archi uscenti.

	sort-topologico(G, DAG)
		1. DFS(G)
		2. inserisci in testa ad una lista L ogni nodo che diventa nero
		3. return L

``````ad-question


Cercare un sync in G rappresentato dalla matrice delle adiacenze

```ad-check
title: Soluzione semplice

	t = 1
	trovato = false
	while t < |v| and !trovato:
		
		if sink-test(G, t):
			t++
		else:
			trovato = true
	return t

	sink-test(G, t):
		j = 1
		while j <= n and G[t, j] == 0: 
			j++
		return !(G[t, j] == 1)

La complessità nel worst case è $O(v^2)$ 
```


``````

# Memorizzare Un Grafo

$$G=(V,E)$$

![[Pasted image 20230301102407.png]]

## Matrice Delle Adiacenze

| |1|2|3|4|
|---|---|---|---|---|
|1| 0 | 1 | 1 | 0|
|2| 1|0|1|0|
|3| 1| 1 | 0| 1
|4| 0| 0 | 1 | 0

## Lista Delle Adiacenze
|i | $\to$ |lista| |
|---|---|---|---|
| 1 | $\to$ | 2 | 3 |
| 2 | $\to$ | 1 | 3 |
| 3 | $\to$| 1 | 4 |
|4| $\to$|3|

## Vettore Delle Adiacenze

Sono 2  vettori:
- $V$ che contiene la posizione in E in cui è presente il primo arco uscente.
- $E$ in cui sono scritti quali archi sono collegati

| | v|
|---|---|
|1|1|
|2|3|
|3|4|
|4|-|

| | E|
|---|---|
| 1|2|
|2|3|
|3|3|
|4|4|

# Complessità Di Un Grafo

A seconda se il grafo sia sparso oppure denso la complessità del suo arco varia da $\Theta(n)$ a $\Theta(n^2)$.

L'[[#Esplorare Un Grafo|esplorazione]] di un grafo impiega $\Omega(V+E)$ (complessità intrinseca), ma a seconda della sua struttura dati può costare:
- Lista delle adiacenze, vettore delle adiacenze $O(V+E)$
- Matrice delle adiacenze $O(v^2)$

# Componenti Fortemente Connesse

Per ogni coppia $(u, v) \in V$ di vertici esiste un cammino $u \to v$ che li lega

![[fortemente_connesso.svg|center]]
$$(2,4) \to2,3,4$$
$$(4,2)\to4,5,1,2$$

## Conta CFC

	dfs(G = (V, E)):
		for v in V:
			color(v) = white
			P(v) = nil
		num_cc = 0
		for i = 1:|v|
			if color(i) == white:
				num_cc++
				dfs-visit(G, i)

num_cc indica le componenti connesse

## Associare a Ogni Vertice La Componente Connessa

Basta chiamare dfs-visit passando il valore di num_cc

	dfs-visit(G, i, num_cc)



```ad-example

![[esempio.svg|center]]

| | 1 | 2 | 3 | 4 | 5 | 6 |
|---|---|---|---|---|---|---|
| color| g | g | g | g | g | g|
|P| nil | 1 | 2 | 3 | 4 | 5 |
|

```ad-missing
title: Riguardare 15-03-2023


```

## Grafo Delle Componenti Fortemente Connesse (C.F.C.)

i vertici sono componenti fortemente connesse e gli archi sono gli archi del grafo originario che vanno da una CFC a un'altra.

$$G^{scc} = \{V;E\}$$
![[componenti.svg|center  mid]]
```ad-info

Una componente fortemente connessa corrisponde a un albero i cui vertici sono i vertici della componente fortemente connessa

```

```ad-important

Per disegnare questo grafo mi interessano solo gli archi che vanno da vertici appartenenti a componenti fortemente connesse

```

``````ad-example
title: supponiamo per assurdo che il grafo non sia un DAG

![[non_dag.svg|center]]

```ad-failure

Esistendo l'arco B, l'intero grafo diventa una componente fortemente connessa, non rendendolo più un $G^{scc}$

```

``````
 

# Grafo Trasposto

Grafo con tutti gli archi invertiti

```ad-example
 ![[trasposto.svg|center]]


ho trovato un albero radicato in 1

```
|       | 1   | 2   | 3   | 4   | 5   | 6   |
| ----- | --- | --- | --- | --- | --- | --- |
| color | g   | g   | g   | g   | g   | g   |
| P     | nil | 3   | 1   | nil | nil | nil |
| d     | 1   | 3   | 2   | 7   | 9   | 11  |
| h     | 6   | 4   | 5   | 8   | 10  | 12  |

# Quadrato Di Un Grafo

Vogliamo calcolare il grafo $G^2$ che ha gli stessi vertici di $G$ ma ha come vertici $E^2$

$$G^2=(V, E^2)$$

$$e \in E \iff e = e_1 e_0, e_1 \in E, e_0 \in E$$
$$(i, j) \in E^2 \implies (i, w) \in E \wedge (w, j) \in E$$
![[Algoritmi/Untitled Diagram.svg|center big]]


```ad-missing
title: [[Riguardare]] 21-03-2023


```


Dato un grafo G trovare il diametro di Gs

![[Algoritmi/Untitled Diagram 1.svg|center]]

