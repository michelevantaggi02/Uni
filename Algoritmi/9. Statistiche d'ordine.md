Selezionare l' $i$esimo elemento più piccolo di $n$ elementi (L'elemento con __rango__ $i$ )

```ad-tip

- $i=1$ minimo
- $i=n$ massimo

```

Algoritmo "ingenuo" : ordinare e scegliere l'elemento di indice $i$, impiegherebbe un tempo di esecuzione peggiore di $\Theta(n \log n)$ usando [[5. Divide et impera#Merge Sort|merge sort]] o [[7. Heapsort|heapsort]].

Questo però non ci da la complessità intrinseca del problema.

``````ad-example

Se vogliamo trovare l'elemento piccolo (o massimo) basta scorrere la lista e trovarli con gli algoritmi già studiati, impiegherebbe un tempo lineare.

Se vogliamo trovare il il secondo elemento più piccolo, basta trovare il più piccolo e rimuoverlo, cercando di nuovo l'elemento più piccolo sarà il secondo (e viceversa con il secondo elemento più grande). In questo caso il tempo di esecuzione è sempre lineare, in quanto impiegherebbe $2n$.

```ad-check

Utilizzando questo sistema la complessità dell'algoritmo è $in$ 

```



``````

Questa complessità è lineare finché $i$ è una costante.

Quando $i=f(n)$

```ad-example
title: Mediana

- $n$ dispari $f(n) = \frac {n+1}2$
- $n$ pari $f(n) = \lfloor \frac {n+1}2 \rfloor \lceil \frac {n+1}2 \rceil$

La complessità diventa $f(n)n$, il caso peggiore avviene con la mediana.

```

# Divide and Conquer Random

	
	Rand-Select(A, p, q, i) => iesimo elemento più piccolo di A[p...q]
		if p > q: 
			return A[p]
		r = Rand-Partition(A,p,q)
		k = r - p - 1 => k = rank(A[r])
		if i == k: 
			return A[r]
		if i < k:
			return Rand-Select(A, p, r-1, i)
		else:
			return Rand-Select(A, r+1, q, i-k)


```ad-example

Riguardare 27-02-2023

```

```ad-question
title: Qual è il rango di $A[r] \in A$?
collapse: open

|index | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
|---|---|---|---|---|---|---|---|---|
| A | 8 | 7 | 1 | 9 | 2 | 5 | 3 | 6 |

$rank(A[3]) = 1$

```


```ad-question
title: Qual è l'elemento di rango $i$?
collapse: open

|index | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
|---|---|---|---|---|---|---|---|---|
| A | 8 | 7 | 1 | 9 | 2 | 5 | 3 | 6 |


Trovo l'elemento più piccolo dell'array e ripeto con $i-1$ fino a che $i$ non diventa 1.

```
